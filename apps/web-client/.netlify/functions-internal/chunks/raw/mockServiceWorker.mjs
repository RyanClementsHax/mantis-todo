// ROLLUP_NO_REPLACE 
 const mockServiceWorker = "/* eslint-disable */\n/* tslint:disable */\n\n/**\n * Mock Service Worker (1.3.2).\n * @see https://github.com/mswjs/msw\n * - Please do NOT modify this file.\n * - Please do NOT serve this file on production.\n */\n\nconst INTEGRITY_CHECKSUM = '3d6b9f06410d179a7f7404d4bf4c3c70';\nconst activeClientIds = new Set();\n\nself.addEventListener('install', function () {\n  self.skipWaiting();\n});\n\nself.addEventListener('activate', function (event) {\n  event.waitUntil(self.clients.claim());\n});\n\nself.addEventListener('message', async function (event) {\n  const clientId = event.source.id;\n\n  if (!clientId || !self.clients) {\n    return;\n  }\n\n  const client = await self.clients.get(clientId);\n\n  if (!client) {\n    return;\n  }\n\n  const allClients = await self.clients.matchAll({\n    type: 'window',\n  });\n\n  switch (event.data) {\n    case 'KEEPALIVE_REQUEST': {\n      sendToClient(client, {\n        type: 'KEEPALIVE_RESPONSE',\n      });\n      break;\n    }\n\n    case 'INTEGRITY_CHECK_REQUEST': {\n      sendToClient(client, {\n        type: 'INTEGRITY_CHECK_RESPONSE',\n        payload: INTEGRITY_CHECKSUM,\n      });\n      break;\n    }\n\n    case 'MOCK_ACTIVATE': {\n      activeClientIds.add(clientId);\n\n      sendToClient(client, {\n        type: 'MOCKING_ENABLED',\n        payload: true,\n      });\n      break;\n    }\n\n    case 'MOCK_DEACTIVATE': {\n      activeClientIds.delete(clientId);\n      break;\n    }\n\n    case 'CLIENT_CLOSED': {\n      activeClientIds.delete(clientId);\n\n      const remainingClients = allClients.filter((client) => {\n        return client.id !== clientId;\n      });\n\n      // Unregister itself when there are no more clients\n      if (remainingClients.length === 0) {\n        self.registration.unregister();\n      }\n\n      break;\n    }\n  }\n});\n\nself.addEventListener('fetch', function (event) {\n  const { request } = event;\n  const accept = request.headers.get('accept') || '';\n\n  // Bypass server-sent events.\n  if (accept.includes('text/event-stream')) {\n    return;\n  }\n\n  // Bypass navigation requests.\n  if (request.mode === 'navigate') {\n    return;\n  }\n\n  // Opening the DevTools triggers the \"only-if-cached\" request\n  // that cannot be handled by the worker. Bypass such requests.\n  if (request.cache === 'only-if-cached' && request.mode !== 'same-origin') {\n    return;\n  }\n\n  // Bypass all requests when there are no active clients.\n  // Prevents the self-unregistered worked from handling requests\n  // after it's been deleted (still remains active until the next reload).\n  if (activeClientIds.size === 0) {\n    return;\n  }\n\n  // Generate unique request ID.\n  const requestId = Math.random().toString(16).slice(2);\n\n  event.respondWith(\n    handleRequest(event, requestId).catch((error) => {\n      if (error.name === 'NetworkError') {\n        console.warn(\n          '[MSW] Successfully emulated a network error for the \"%s %s\" request.',\n          request.method,\n          request.url,\n        );\n        return;\n      }\n\n      // At this point, any exception indicates an issue with the original request/response.\n      console.error(\n        `\\\n[MSW] Caught an exception from the \"%s %s\" request (%s). This is probably not a problem with Mock Service Worker. There is likely an additional logging output above.`,\n        request.method,\n        request.url,\n        `${error.name}: ${error.message}`,\n      );\n    }),\n  );\n});\n\nasync function handleRequest(event, requestId) {\n  const client = await resolveMainClient(event);\n  const response = await getResponse(event, client, requestId);\n\n  // Send back the response clone for the \"response:*\" life-cycle events.\n  // Ensure MSW is active and ready to handle the message, otherwise\n  // this message will pend indefinitely.\n  if (client && activeClientIds.has(client.id)) {\n    (async function () {\n      const clonedResponse = response.clone();\n      sendToClient(client, {\n        type: 'RESPONSE',\n        payload: {\n          requestId,\n          type: clonedResponse.type,\n          ok: clonedResponse.ok,\n          status: clonedResponse.status,\n          statusText: clonedResponse.statusText,\n          body:\n            clonedResponse.body === null ? null : await clonedResponse.text(),\n          headers: Object.fromEntries(clonedResponse.headers.entries()),\n          redirected: clonedResponse.redirected,\n        },\n      });\n    })();\n  }\n\n  return response;\n}\n\n// Resolve the main client for the given event.\n// Client that issues a request doesn't necessarily equal the client\n// that registered the worker. It's with the latter the worker should\n// communicate with during the response resolving phase.\nasync function resolveMainClient(event) {\n  const client = await self.clients.get(event.clientId);\n\n  if (client?.frameType === 'top-level') {\n    return client;\n  }\n\n  const allClients = await self.clients.matchAll({\n    type: 'window',\n  });\n\n  return allClients\n    .filter((client) => {\n      // Get only those clients that are currently visible.\n      return client.visibilityState === 'visible';\n    })\n    .find((client) => {\n      // Find the client ID that's recorded in the\n      // set of clients that have registered the worker.\n      return activeClientIds.has(client.id);\n    });\n}\n\nasync function getResponse(event, client, requestId) {\n  const { request } = event;\n  const clonedRequest = request.clone();\n\n  function passthrough() {\n    // Clone the request because it might've been already used\n    // (i.e. its body has been read and sent to the client).\n    const headers = Object.fromEntries(clonedRequest.headers.entries());\n\n    // Remove MSW-specific request headers so the bypassed requests\n    // comply with the server's CORS preflight check.\n    // Operate with the headers as an object because request \"Headers\"\n    // are immutable.\n    delete headers['x-msw-bypass'];\n\n    return fetch(clonedRequest, { headers });\n  }\n\n  // Bypass mocking when the client is not active.\n  if (!client) {\n    return passthrough();\n  }\n\n  // Bypass initial page load requests (i.e. static assets).\n  // The absence of the immediate/parent client in the map of the active clients\n  // means that MSW hasn't dispatched the \"MOCK_ACTIVATE\" event yet\n  // and is not ready to handle requests.\n  if (!activeClientIds.has(client.id)) {\n    return passthrough();\n  }\n\n  // Bypass requests with the explicit bypass header.\n  // Such requests can be issued by \"ctx.fetch()\".\n  if (request.headers.get('x-msw-bypass') === 'true') {\n    return passthrough();\n  }\n\n  // Notify the client that a request has been intercepted.\n  const clientMessage = await sendToClient(client, {\n    type: 'REQUEST',\n    payload: {\n      id: requestId,\n      url: request.url,\n      method: request.method,\n      headers: Object.fromEntries(request.headers.entries()),\n      cache: request.cache,\n      mode: request.mode,\n      credentials: request.credentials,\n      destination: request.destination,\n      integrity: request.integrity,\n      redirect: request.redirect,\n      referrer: request.referrer,\n      referrerPolicy: request.referrerPolicy,\n      body: await request.text(),\n      bodyUsed: request.bodyUsed,\n      keepalive: request.keepalive,\n    },\n  });\n\n  switch (clientMessage.type) {\n    case 'MOCK_RESPONSE': {\n      return respondWithMock(clientMessage.data);\n    }\n\n    case 'MOCK_NOT_FOUND': {\n      return passthrough();\n    }\n\n    case 'NETWORK_ERROR': {\n      const { name, message } = clientMessage.data;\n      const networkError = new Error(message);\n      networkError.name = name;\n\n      // Rejecting a \"respondWith\" promise emulates a network error.\n      throw networkError;\n    }\n  }\n\n  return passthrough();\n}\n\nfunction sendToClient(client, message) {\n  return new Promise((resolve, reject) => {\n    const channel = new MessageChannel();\n\n    channel.port1.onmessage = (event) => {\n      if (event.data && event.data.error) {\n        return reject(event.data.error);\n      }\n\n      resolve(event.data);\n    };\n\n    client.postMessage(message, [channel.port2]);\n  });\n}\n\nfunction sleep(timeMs) {\n  return new Promise((resolve) => {\n    setTimeout(resolve, timeMs);\n  });\n}\n\nasync function respondWithMock(response) {\n  await sleep(response.delay);\n  return new Response(response.body, response);\n}\n";

export { mockServiceWorker as default };
//# sourceMappingURL=mockServiceWorker.mjs.map
